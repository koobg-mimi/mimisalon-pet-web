{"version":3,"sources":["turbopack:///[project]/node_modules/date-fns/constants.js","turbopack:///[project]/node_modules/date-fns/constructFrom.js","turbopack:///[project]/node_modules/date-fns/toDate.js","turbopack:///[project]/src/lib/booking-availability.ts","turbopack:///[project]/node_modules/date-fns/parseISO.js"],"sourcesContent":["/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n","import { constructFromSymbol } from \"./constants.js\";\n\n/**\n * @name constructFrom\n * @category Generic Helpers\n * @summary Constructs a date using the reference date and the value\n *\n * @description\n * The function constructs a new date using the constructor from the reference\n * date and the given value. It helps to build generic functions that accept\n * date extensions.\n *\n * It defaults to `Date` if the passed reference date is a number or a string.\n *\n * Starting from v3.7.0, it allows to construct a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The reference date to take constructor from\n * @param value - The value to create the date\n *\n * @returns Date initialized using the given date and value\n *\n * @example\n * import { constructFrom } from \"./constructFrom/date-fns\";\n *\n * // A function that clones a date preserving the original type\n * function cloneDate<DateType extends Date>(date: DateType): DateType {\n *   return constructFrom(\n *     date, // Use constructor from the given date\n *     date.getTime() // Use the date value to create a new date\n *   );\n * }\n */\nexport function constructFrom(date, value) {\n  if (typeof date === \"function\") return date(value);\n\n  if (date && typeof date === \"object\" && constructFromSymbol in date)\n    return date[constructFromSymbol](value);\n\n  if (date instanceof Date) return new date.constructor(value);\n\n  return new Date(value);\n}\n\n// Fallback for modularized imports:\nexport default constructFrom;\n","import { constructFrom } from \"./constructFrom.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate(argument, context) {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\n// Fallback for modularized imports:\nexport default toDate;\n","import { prisma } from '@mimisalon/shared';\nimport { Prisma } from '@mimisalon/shared';\n\n/**\n * 서비스 후 정리 및 준비 시간 (분)\n * 모든 예약에 대해 서비스 시간 외에 추가로 차단되는 시간\n */\nexport const CLEANUP_BUFFER_MINUTES = 90;\n\n/**\n * 예약 시 필요한 시간 슬롯 목록 생성\n * @param startTime 시작 시간 (HH:mm)\n * @param durationMinutes 서비스 소요 시간 (분)\n * @returns 필요한 시간 슬롯 배열\n */\nexport function generateRequiredTimeSlots(startTime: string, durationMinutes: number): string[] {\n  const slots: string[] = [];\n  const [startHour, startMinute] = startTime.split(':').map(Number);\n\n  let currentMinutes = startHour * 60 + startMinute;\n  const endMinutes = currentMinutes + durationMinutes;\n\n  while (currentMinutes < endMinutes) {\n    const hour = Math.floor(currentMinutes / 60);\n    const minute = currentMinutes % 60;\n    const timeSlot = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;\n    slots.push(timeSlot);\n    currentMinutes += 30; // 30분 단위 슬롯\n  }\n\n  return slots;\n}\n\n/**\n * 미용사의 특정 날짜/시간 슬롯이 예약 가능한지 확인\n * @param groomerId 미용사 ID\n * @param date 예약 날짜\n * @param timeSlots 확인할 시간 슬롯들\n * @returns 예약 가능 여부\n */\nexport async function checkGroomerAvailability(\n  groomerId: string,\n  date: Date,\n  timeSlots: string[]\n): Promise<{ available: boolean; conflicts?: string[] }> {\n  // 1. 기존 예약 확인\n  const existingBookings = await prisma.booking.findMany({\n    where: {\n      groomerId,\n      serviceDate: date,\n      status: {\n        notIn: ['SERVICE_CANCELLED', 'BOOKING_FAILED'],\n      },\n    },\n    select: {\n      serviceTime: true,\n      estimatedDurationMinutes: true,\n    },\n  });\n\n  const conflictingSlots = new Set<string>();\n\n  // 2. 각 기존 예약의 시간 슬롯 계산 (정리 시간 포함)\n  for (const booking of existingBookings) {\n    const bookedSlots = generateRequiredTimeSlots(\n      booking.serviceTime,\n      (booking.estimatedDurationMinutes || 60) + CLEANUP_BUFFER_MINUTES\n    );\n    bookedSlots.forEach((slot) => conflictingSlots.add(slot));\n  }\n\n  // 3. 요청된 시간 슬롯과 충돌 확인\n  const conflicts = timeSlots.filter((slot) => conflictingSlots.has(slot));\n\n  if (conflicts.length > 0) {\n    return { available: false, conflicts };\n  }\n\n  // 4. GroomerAvailability 테이블 확인 (명시적으로 차단된 시간)\n  const blockedSlots = await prisma.groomerAvailability.findMany({\n    where: {\n      groomerId,\n      date,\n      timeSlot: { in: timeSlots },\n      OR: [{ isAvailable: false }, { isBooked: true }],\n    },\n    select: {\n      timeSlot: true,\n    },\n  });\n\n  if (blockedSlots.length > 0) {\n    return {\n      available: false,\n      conflicts: blockedSlots.map((s) => s.timeSlot),\n    };\n  }\n\n  return { available: true };\n}\n\n/**\n * 예약 생성 시 시간 슬롯 차단 (트랜잭션 내에서 실행)\n * @param tx Prisma 트랜잭션 클라이언트\n * @param groomerId 미용사 ID\n * @param date 예약 날짜\n * @param timeSlots 차단할 시간 슬롯들\n * @param bookingId 예약 ID\n */\nexport async function blockTimeSlots(\n  tx: Prisma.TransactionClient,\n  groomerId: string,\n  date: Date,\n  timeSlots: string[],\n  bookingId: string\n): Promise<void> {\n  // 1. 이미 예약된 시간인지 최종 확인 (트랜잭션 내에서)\n  const existingBookings = await tx.booking.findMany({\n    where: {\n      groomerId,\n      serviceDate: date,\n      status: {\n        notIn: ['SERVICE_CANCELLED', 'BOOKING_FAILED'],\n      },\n      NOT: {\n        id: bookingId, // 자기 자신 제외\n      },\n    },\n    select: {\n      serviceTime: true,\n      estimatedDurationMinutes: true,\n    },\n  });\n\n  const conflictingSlots = new Set<string>();\n  for (const booking of existingBookings) {\n    const bookedSlots = generateRequiredTimeSlots(\n      booking.serviceTime,\n      (booking.estimatedDurationMinutes || 60) + CLEANUP_BUFFER_MINUTES\n    );\n    bookedSlots.forEach((slot) => conflictingSlots.add(slot));\n  }\n\n  const conflicts = timeSlots.filter((slot) => conflictingSlots.has(slot));\n  if (conflicts.length > 0) {\n    throw new Error(`다음 시간은 이미 예약되었습니다: ${conflicts.join(', ')}`);\n  }\n\n  // 2. GroomerAvailability 레코드 생성 또는 업데이트\n  // 먼저 스케줄 확인\n  const schedule = await tx.groomerSchedule.findUnique({\n    where: { groomerId },\n  });\n\n  const scheduleId = schedule?.id;\n\n  // 3. 각 시간 슬롯을 차단\n  for (const timeSlot of timeSlots) {\n    await tx.groomerAvailability.upsert({\n      where: {\n        groomerId_date_timeSlot: {\n          groomerId,\n          date,\n          timeSlot,\n        },\n      },\n      update: {\n        isBooked: true,\n        bookingId,\n        isAvailable: false,\n      },\n      create: {\n        groomerId,\n        scheduleId: scheduleId || '',\n        date,\n        timeSlot,\n        isBooked: true,\n        bookingId,\n        isAvailable: false,\n      },\n    });\n  }\n}\n\n/**\n * 예약 취소 시 시간 슬롯 해제\n * @param bookingId 예약 ID\n */\nexport async function releaseTimeSlots(bookingId: string): Promise<void> {\n  await prisma.groomerAvailability.updateMany({\n    where: {\n      bookingId,\n    },\n    data: {\n      isBooked: false,\n      bookingId: undefined,\n      isAvailable: true,\n    },\n  });\n}\n\n/**\n * 실시간 예약 상태 조회\n * @param groomerId 미용사 ID\n * @param date 조회할 날짜\n * @returns 해당 날짜의 예약 상태\n */\nexport async function getGroomerDaySchedule(groomerId: string, date: Date) {\n  // 1. 해당 날짜의 모든 예약 조회\n  const bookings = await prisma.booking.findMany({\n    where: {\n      groomerId,\n      serviceDate: date,\n      status: {\n        notIn: ['SERVICE_CANCELLED', 'BOOKING_FAILED'],\n      },\n    },\n    select: {\n      id: true,\n      serviceTime: true,\n      estimatedDurationMinutes: true,\n      status: true,\n      customer: {\n        select: {\n          name: true,\n        },\n      },\n    },\n  });\n\n  // 2. 명시적으로 차단된 시간 조회\n  const blockedSlots = await prisma.groomerAvailability.findMany({\n    where: {\n      groomerId,\n      date,\n      OR: [{ isAvailable: false }, { isBooked: true }],\n    },\n    select: {\n      timeSlot: true,\n      isBooked: true,\n      bookingId: true,\n    },\n  });\n\n  // 3. 시간별 상태 맵 생성\n  const timeSlotStatus = new Map<\n    string,\n    {\n      available: boolean;\n      bookingId?: string;\n      customerName?: string;\n      status?: string;\n    }\n  >();\n\n  // 예약된 시간 처리 (정리 시간 포함)\n  for (const booking of bookings) {\n    const slots = generateRequiredTimeSlots(\n      booking.serviceTime,\n      (booking.estimatedDurationMinutes || 60) + CLEANUP_BUFFER_MINUTES\n    );\n\n    slots.forEach((slot) => {\n      timeSlotStatus.set(slot, {\n        available: false,\n        bookingId: booking.id,\n        customerName: booking.customer?.name || undefined,\n        status: booking.status,\n      });\n    });\n  }\n\n  // 명시적으로 차단된 시간 처리\n  for (const blocked of blockedSlots) {\n    if (!timeSlotStatus.has(blocked.timeSlot)) {\n      timeSlotStatus.set(blocked.timeSlot, {\n        available: false,\n        bookingId: blocked.bookingId || undefined,\n      });\n    }\n  }\n\n  return timeSlotStatus;\n}\n","import {\n  millisecondsInHour,\n  millisecondsInMinute,\n} from \"./constants.js\";\nimport { constructFrom } from \"./constructFrom.js\";\nimport { toDate } from \"./toDate.js\";\n\n/**\n * The {@link parseISO} function options.\n */\n\n/**\n * @name parseISO\n * @category Common Helpers\n * @summary Parse ISO string\n *\n * @description\n * Parse the given string in ISO 8601 format and return an instance of Date.\n *\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If the argument isn't a string, the function cannot parse the string or\n * the values are invalid, it returns Invalid Date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n * @param options - An object with options\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = parseISO('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = parseISO('+02014101', { additionalDigits: 1 })\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport function parseISO(argument, options) {\n  const invalidDate = () => constructFrom(options?.in, NaN);\n\n  const additionalDigits = options?.additionalDigits ?? 2;\n  const dateStrings = splitDateString(argument);\n\n  let date;\n  if (dateStrings.date) {\n    const parseYearResult = parseYear(dateStrings.date, additionalDigits);\n    date = parseDate(parseYearResult.restDateString, parseYearResult.year);\n  }\n\n  if (!date || isNaN(+date)) return invalidDate();\n\n  const timestamp = +date;\n  let time = 0;\n  let offset;\n\n  if (dateStrings.time) {\n    time = parseTime(dateStrings.time);\n    if (isNaN(time)) return invalidDate();\n  }\n\n  if (dateStrings.timezone) {\n    offset = parseTimezone(dateStrings.timezone);\n    if (isNaN(offset)) return invalidDate();\n  } else {\n    const tmpDate = new Date(timestamp + time);\n    const result = toDate(0, options?.in);\n    result.setFullYear(\n      tmpDate.getUTCFullYear(),\n      tmpDate.getUTCMonth(),\n      tmpDate.getUTCDate(),\n    );\n    result.setHours(\n      tmpDate.getUTCHours(),\n      tmpDate.getUTCMinutes(),\n      tmpDate.getUTCSeconds(),\n      tmpDate.getUTCMilliseconds(),\n    );\n    return result;\n  }\n\n  return toDate(timestamp + time + offset, options?.in);\n}\n\nconst patterns = {\n  dateTimeDelimiter: /[T ]/,\n  timeZoneDelimiter: /[Z ]/i,\n  timezone: /([Z+-].*)$/,\n};\n\nconst dateRegex =\n  /^-?(?:(\\d{3})|(\\d{2})(?:-?(\\d{2}))?|W(\\d{2})(?:-?(\\d{1}))?|)$/;\nconst timeRegex =\n  /^(\\d{2}(?:[.,]\\d*)?)(?::?(\\d{2}(?:[.,]\\d*)?))?(?::?(\\d{2}(?:[.,]\\d*)?))?$/;\nconst timezoneRegex = /^([+-])(\\d{2})(?::?(\\d{2}))?$/;\n\nfunction splitDateString(dateString) {\n  const dateStrings = {};\n  const array = dateString.split(patterns.dateTimeDelimiter);\n  let timeString;\n\n  // The regex match should only return at maximum two array elements.\n  // [date], [time], or [date, time].\n  if (array.length > 2) {\n    return dateStrings;\n  }\n\n  if (/:/.test(array[0])) {\n    timeString = array[0];\n  } else {\n    dateStrings.date = array[0];\n    timeString = array[1];\n    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {\n      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];\n      timeString = dateString.substr(\n        dateStrings.date.length,\n        dateString.length,\n      );\n    }\n  }\n\n  if (timeString) {\n    const token = patterns.timezone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], \"\");\n      dateStrings.timezone = token[1];\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n\n  return dateStrings;\n}\n\nfunction parseYear(dateString, additionalDigits) {\n  const regex = new RegExp(\n    \"^(?:(\\\\d{4}|[+-]\\\\d{\" +\n      (4 + additionalDigits) +\n      \"})|(\\\\d{2}|[+-]\\\\d{\" +\n      (2 + additionalDigits) +\n      \"})$)\",\n  );\n\n  const captures = dateString.match(regex);\n  // Invalid ISO-formatted year\n  if (!captures) return { year: NaN, restDateString: \"\" };\n\n  const year = captures[1] ? parseInt(captures[1]) : null;\n  const century = captures[2] ? parseInt(captures[2]) : null;\n\n  // either year or century is null, not both\n  return {\n    year: century === null ? year : century * 100,\n    restDateString: dateString.slice((captures[1] || captures[2]).length),\n  };\n}\n\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) return new Date(NaN);\n\n  const captures = dateString.match(dateRegex);\n  // Invalid ISO-formatted string\n  if (!captures) return new Date(NaN);\n\n  const isWeekDate = !!captures[4];\n  const dayOfYear = parseDateUnit(captures[1]);\n  const month = parseDateUnit(captures[2]) - 1;\n  const day = parseDateUnit(captures[3]);\n  const week = parseDateUnit(captures[4]);\n  const dayOfWeek = parseDateUnit(captures[5]) - 1;\n\n  if (isWeekDate) {\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  } else {\n    const date = new Date(0);\n    if (\n      !validateDate(year, month, day) ||\n      !validateDayOfYearDate(year, dayOfYear)\n    ) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));\n    return date;\n  }\n}\n\nfunction parseDateUnit(value) {\n  return value ? parseInt(value) : 1;\n}\n\nfunction parseTime(timeString) {\n  const captures = timeString.match(timeRegex);\n  if (!captures) return NaN; // Invalid ISO-formatted time\n\n  const hours = parseTimeUnit(captures[1]);\n  const minutes = parseTimeUnit(captures[2]);\n  const seconds = parseTimeUnit(captures[3]);\n\n  if (!validateTime(hours, minutes, seconds)) {\n    return NaN;\n  }\n\n  return (\n    hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000\n  );\n}\n\nfunction parseTimeUnit(value) {\n  return (value && parseFloat(value.replace(\",\", \".\"))) || 0;\n}\n\nfunction parseTimezone(timezoneString) {\n  if (timezoneString === \"Z\") return 0;\n\n  const captures = timezoneString.match(timezoneRegex);\n  if (!captures) return 0;\n\n  const sign = captures[1] === \"+\" ? -1 : 1;\n  const hours = parseInt(captures[2]);\n  const minutes = (captures[3] && parseInt(captures[3])) || 0;\n\n  if (!validateTimezone(hours, minutes)) {\n    return NaN;\n  }\n\n  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);\n}\n\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  const date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  const fourthOfJanuaryDay = date.getUTCDay() || 7;\n  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n}\n\n// Validation functions\n\n// February is null to handle the leap year (using ||)\nconst daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n}\n\nfunction validateDate(year, month, date) {\n  return (\n    month >= 0 &&\n    month <= 11 &&\n    date >= 1 &&\n    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))\n  );\n}\n\nfunction validateDayOfYearDate(year, dayOfYear) {\n  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);\n}\n\nfunction validateWeekDate(_year, week, day) {\n  return week >= 1 && week <= 53 && day >= 0 && day <= 6;\n}\n\nfunction validateTime(hours, minutes, seconds) {\n  if (hours === 24) {\n    return minutes === 0 && seconds === 0;\n  }\n\n  return (\n    seconds >= 0 &&\n    seconds < 60 &&\n    minutes >= 0 &&\n    minutes < 60 &&\n    hours >= 0 &&\n    hours < 25\n  );\n}\n\nfunction validateTimezone(_hours, minutes) {\n  return minutes >= 0 && minutes <= 59;\n}\n\n// Fallback for modularized imports:\nexport default parseISO;\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,4]}