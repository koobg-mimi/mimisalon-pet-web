module.exports = [
  123987,
  (e) => {
    'use strict'
    var o = e.i(747909),
      t = e.i(174017),
      a = e.i(996250),
      n = e.i(759756),
      r = e.i(561916),
      i = e.i(114444),
      s = e.i(837092),
      l = e.i(869741),
      c = e.i(316795),
      d = e.i(487718),
      u = e.i(995169),
      p = e.i(47587),
      h = e.i(666012),
      g = e.i(570101),
      m = e.i(626937),
      b = e.i(10372),
      f = e.i(193695)
    e.i(52474)
    var w = e.i(600220),
      k = e.i(89171),
      y = e.i(518184)
    function E(e, o) {
      try {
        return e()
      } catch (e) {
        return o(e)
      }
    }
    class I extends y.PortOneError {
      constructor(e) {
        ;(super(e), Object.setPrototypeOf(this, I.prototype), (this.name = 'InvalidInputError'))
      }
    }
    class v extends y.PortOneError {
      reason
      static getMessage(e) {
        switch (e) {
          case 'MISSING_REQUIRED_HEADERS':
            return '필수 헤더가 누락되었습니다.'
          case 'NO_MATCHING_SIGNATURE':
            return '올바른 웹훅 시그니처를 찾을 수 없습니다.'
          case 'INVALID_SIGNATURE':
            return '웹훅 시그니처가 유효하지 않습니다.'
          case 'TIMESTAMP_TOO_OLD':
            return '웹훅 시그니처의 타임스탬프가 만료 기한을 초과했습니다.'
          case 'TIMESTAMP_TOO_NEW':
            return '웹훅 시그니처의 타임스탬프가 미래 시간으로 설정되어 있습니다.'
        }
      }
      constructor(e, o) {
        ;(super(v.getMessage(e), o),
          Object.setPrototypeOf(this, v.prototype),
          (this.name = 'WebhookVerificationError'),
          (this.reason = e))
      }
    }
    let A = 'whsec_'
    function R(e, o) {
      let t
      if ('object' != typeof e || null === e) return
      let a = o.toLowerCase()
      for (let [o, n] of Object.entries(e))
        if (o.toLowerCase() === a) {
          for (let e of Array.isArray(n) ? n : [n])
            if (null != e) {
              if ('string' != typeof e || void 0 !== t) return
              t = e
            }
        }
      return t
    }
    async function P(e, o, t) {
      if ('string' != typeof o) throw new I('`payload` 파라미터의 타입이 string이 아닙니다.')
      let a = R(t, 'webhook-id'),
        n = R(t, 'webhook-signature'),
        r = R(t, 'webhook-timestamp')
      if (!a || !n || !r) throw new v('MISSING_REQUIRED_HEADERS')
      var i = r
      let s = Math.floor(Date.now() / 1e3),
        l = Number.parseInt(i, 10)
      if (Number.isNaN(l)) throw new v('INVALID_SIGNATURE')
      if (s - l > 300) throw new v('TIMESTAMP_TOO_OLD')
      if (l > s + 300) throw new v('TIMESTAMP_TOO_NEW')
      let c = await T(e, a, r, o)
      for (let e of n.split(' ')) {
        let t = e.split(',', 3)
        if (t.length < 2) continue
        let [a, n] = t
        if ('v1' !== a) continue
        let r = E(
          () => Uint8Array.from(atob(n), (e) => e.charCodeAt(0)),
          () => void 0
        )
        if (
          void 0 !== r &&
          (function (e, o) {
            if (e.byteLength !== o.byteLength) return !1
            let t =
                e instanceof DataView
                  ? e
                  : ArrayBuffer.isView(e)
                    ? new DataView(e.buffer, e.byteOffset, e.byteLength)
                    : new DataView(e),
              a =
                o instanceof DataView
                  ? o
                  : ArrayBuffer.isView(o)
                    ? new DataView(o.buffer, o.byteOffset, o.byteLength)
                    : new DataView(o),
              n = t.byteLength,
              r = 0,
              i = -1
            for (; ++i < n; ) r |= t.getUint8(i) ^ a.getUint8(i)
            return 0 === r
          })(r, c)
        )
          return JSON.parse(o)
      }
      throw new v('NO_MATCHING_SIGNATURE')
    }
    async function T(e, o, t, a) {
      let n = await C(e),
        r = new TextEncoder().encode(`${o}.${t}.${a}`)
      return await crypto.subtle.sign('HMAC', n, r)
    }
    let N = new Map()
    async function C(e) {
      let o,
        t = N.get(e)
      if (void 0 !== t) return t
      if (e instanceof Uint8Array) o = new Uint8Array(e)
      else if ('string' == typeof e) {
        let t = e.startsWith(A) ? e.substring(A.length) : e
        o = E(
          () => Uint8Array.from(atob(t), (e) => e.charCodeAt(0)),
          () => {
            throw new I('`secret` 파라미터가 올바른 Base64 문자열이 아닙니다.')
          }
        )
      } else throw new I('`secret` 파라미터의 타입이 잘못되었습니다.')
      if (0 === o.length) throw new I('시크릿은 비어 있을 수 없습니다.')
      let a = await crypto.subtle.importKey(
        'raw',
        o.buffer,
        { name: 'HMAC', hash: 'SHA-256' },
        !1,
        ['sign']
      )
      return (N.set(e, a), a)
    }
    function W(e) {
      return (
        'Transaction.Ready' !== e.type &&
        'Transaction.Paid' !== e.type &&
        'Transaction.VirtualAccountIssued' !== e.type &&
        'Transaction.PartialCancelled' !== e.type &&
        'Transaction.Cancelled' !== e.type &&
        'Transaction.Failed' !== e.type &&
        'Transaction.PayPending' !== e.type &&
        'Transaction.DisputeCreated' !== e.type &&
        'Transaction.DisputeResolved' !== e.type &&
        'Transaction.CancelPending' !== e.type &&
        'Transaction.Confirm' !== e.type &&
        'BillingKey.Ready' !== e.type &&
        'BillingKey.Issued' !== e.type &&
        'BillingKey.Failed' !== e.type &&
        'BillingKey.Deleted' !== e.type &&
        'BillingKey.Updated' !== e.type
      )
    }
    ;(e.s(
      ['InvalidInputError', () => I, 'WebhookVerificationError', () => v, 'verify', () => P],
      763392
    ),
      e.i(763392),
      e.s(['isUnrecognizedWebhook', () => W], 764348),
      e.i(764348),
      e.s(
        [
          'InvalidInputError',
          () => I,
          'WebhookVerificationError',
          () => v,
          'isUnrecognizedWebhook',
          () => W,
          'verify',
          () => P,
        ],
        88853
      ))
    var $ = e.i(88853),
      $ = $,
      S = e.i(657446),
      O = e.i(398163),
      D = e.i(191486),
      _ = e.i(547499)
    async function x(e) {
      let o = e.body?.getReader()
      if (!o) throw Error('No body available')
      let t = []
      for (;;) {
        let { done: e, value: a } = await o.read()
        if (e) break
        t.push(a)
      }
      let a = new Uint8Array(t.reduce((e, o) => e + o.length, 0)),
        n = 0
      for (let e of t) (a.set(e, n), (n += e.length))
      return new TextDecoder().decode(a)
    }
    async function U(e) {
      try {
        let o,
          t = _.env.PORTONE_WEBHOOK_SECRET,
          a = await x(e)
        ;(console.log('[Webhook] Received webhook body:', a),
          'production' === _.env.NODE_ENV &&
            fetch('http://oreopie.ipdisk.co.kr:3000/api/v1/webhooks/portone', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'webhook-id': e.headers.get('webhook-id') || '',
                'webhook-signature': e.headers.get('webhook-signature') || '',
                'webhook-timestamp': e.headers.get('webhook-timestamp') || '',
              },
              body: a,
            }).catch((e) => console.log('[Webhook] Passthrough error:', e)))
        let n =
          e.headers.get('webhook-id') &&
          e.headers.get('webhook-signature') &&
          e.headers.get('webhook-timestamp')
        if (t && n) {
          let n = {
            'webhook-id': e.headers.get('webhook-id') || '',
            'webhook-signature': e.headers.get('webhook-signature') || '',
            'webhook-timestamp': e.headers.get('webhook-timestamp') || '',
          }
          try {
            ;(await $.verify(t, a, n),
              console.log('[Webhook] Signature verified successfully'),
              (o = JSON.parse(a)))
          } catch (e) {
            return (
              console.error('[Webhook] Signature verification failed:', e),
              k.NextResponse.json({ error: 'Invalid webhook signature' }, { status: 401 })
            )
          }
        } else
          (console.warn('[Webhook] Processing without signature verification'), (o = JSON.parse(a)))
        if ('payment_id' in o && 'tx_id' in o && 'status' in o) {
          let { payment_id: e, tx_id: t, status: a } = o
          switch (
            (console.log(`[Webhook] Processing V1 webhook - Payment: ${e}, TX: ${t}, Status: ${a}`),
            a)
          ) {
            case 'Paid':
              await M(e, t, 'v1')
              break
            case 'Failed':
              await F(e, t)
              break
            case 'Cancelled':
            case 'PartialCancelled':
              await L(e, t, 'PartialCancelled' === a)
              break
            case 'Ready':
            case 'VirtualAccountIssued':
              await B(e, t)
              break
            default:
              console.log(`[Webhook] Unhandled webhook status: ${a}`)
          }
        } else {
          if (!('type' in o) || !('data' in o))
            return (
              console.error('[Webhook] Unknown webhook format:', o),
              k.NextResponse.json({ error: 'Unknown webhook format' }, { status: 400 })
            )
          let { type: e, data: t } = o
          if ((console.log(`[Webhook] Processing V2 webhook - Type: ${e}`), t.paymentId)) {
            let { paymentId: o, transactionId: a } = t
            switch (e) {
              case 'Transaction.Paid':
                await M(o, a || '', 'v2')
                break
              case 'Transaction.Failed':
                await F(o, a || '')
                break
              case 'Transaction.Cancelled':
              case 'Transaction.PartialCancelled':
                await L(o, a || '', 'Transaction.PartialCancelled' === e)
                break
              case 'Transaction.Ready':
              case 'Transaction.VirtualAccountIssued':
                await B(o, a || '')
                break
              default:
                console.log(`[Webhook] Unhandled webhook type: ${e}`)
            }
          }
        }
        return k.NextResponse.json({ received: !0 }, { status: 200 })
      } catch (e) {
        return (
          console.error('[Webhook] Error processing webhook:', e),
          k.NextResponse.json({ error: 'Failed to process webhook' }, { status: 500 })
        )
      }
    }
    async function M(o, t, a = 'v1') {
      try {
        console.log(`[Webhook] Processing payment success for ${o}, TX: ${t}, Version: ${a}`)
        try {
          ;(await O.workerApiClient.cancelPaymentCleanup(o),
            console.log(`[Webhook] Cancelled cleanup job for successful payment: ${o}`))
        } catch (e) {
          console.error('[Webhook] Failed to cancel cleanup job:', e)
        }
        let n = await S.prisma.payment.findUnique({ where: { paymentId: o } })
        if (!n) return void console.warn(`[Webhook] Payment not found in database: ${o}`)
        if ('v2' === a)
          try {
            let { getPaymentDetails: t } = await e.A(106100),
              a = await t(o),
              r = 'object' == typeof a && a && 'amount' in a ? a.amount?.total : void 0
            if (void 0 !== r && r !== n.amount) {
              ;(console.error('[Webhook] Amount mismatch detected:', {
                paymentId: o,
                expected: n.amount,
                actual: r,
              }),
                await S.prisma.payment.update({
                  where: { paymentId: o },
                  data: {
                    status: 'FAILED',
                    failReason: `Amount mismatch: expected ${n.amount}, got ${r}`,
                  },
                }))
              return
            }
            console.log(`[Webhook] Amount validation passed for ${o}: ${n.amount}`)
          } catch (e) {
            console.error('[Webhook] Failed to validate payment amount:', e)
          }
        else console.log(`[Webhook] Skipping V2 SDK validation for V1 payment: ${o}`)
        let r = { paymentId: o, transactionId: t, status: 'PAID', paidAt: new Date() },
          i = await S.prisma.payment.update({
            where: { paymentId: o },
            data: { status: r.status, paidAt: r.paidAt, pgTxId: t },
          })
        if (i.bookingId) {
          let e = await S.prisma.booking.findUnique({
            where: { id: i.bookingId },
            select: { status: !0 },
          })
          if (e) {
            let t,
              a = { paymentStatus: 'PAID', updatedAt: new Date() }
            switch (e.status) {
              case S.BookingStatus.FIRST_PAYMENT_PENDING:
                ;((t = S.BookingStatus.GROOMER_CONFIRM_PENDING),
                  console.log(
                    `[Webhook] First payment completed for booking ${i.bookingId} - waiting for groomer confirmation`
                  ))
                try {
                  await V(i.bookingId)
                } catch (e) {
                  console.error('[Webhook] Failed to send groomer notification:', e)
                }
                break
              case S.BookingStatus.ADDITIONAL_PAYMENT_PENDING:
              case S.BookingStatus.ADDITIONAL_PAYMENT_COMPLETE:
                ;((t = S.BookingStatus.WORK_IN_PROGRESS),
                  console.log(
                    `[Webhook] Additional payment confirmed for booking ${i.bookingId} - resuming work`
                  ))
                try {
                  await H(i.bookingId)
                } catch (e) {
                  console.error(
                    '[Webhook] Failed to send groomer additional payment notification:',
                    e
                  )
                }
                break
              default:
                ;((t = e.status),
                  console.warn(
                    `[Webhook] Unexpected booking status ${e.status} for payment ${o} on booking ${i.bookingId}`
                  ))
            }
            ;((a.status = t),
              await S.prisma.booking.update({ where: { id: i.bookingId }, data: a }),
              console.log(`[Webhook] Booking ${i.bookingId} status updated: ${e.status} → ${t}`))
          }
        }
        console.log(`[Webhook] Payment success processed: ${o}`)
      } catch (e) {
        throw (console.error('[Webhook] Error handling payment success:', e), e)
      }
    }
    async function F(e, o) {
      try {
        if ((console.log(`[Webhook] Processing payment failure for ${e}, TX: ${o}`), !e))
          return void console.error('[Webhook] Cannot process payment failure without paymentId')
        try {
          ;(await O.workerApiClient.executePaymentCleanup({ paymentId: e }),
            console.log(`[Webhook] Executed immediate cleanup for failed payment: ${e}`))
        } catch (e) {
          console.error('[Webhook] Failed to execute immediate cleanup:', e)
        }
        let t = await S.prisma.payment.findUnique({
          where: { paymentId: e },
          include: { booking: !0 },
        })
        if (t) {
          let a = await S.prisma.payment.update({
            where: { paymentId: e },
            data: { status: 'FAILED', failedAt: new Date(), pgTxId: o },
          })
          if (a.bookingId && t.booking) {
            let e = t.booking
            'FIRST_PAYMENT_PENDING' === e.status
              ? (console.log(`[Webhook] Cleaning up failed booking ${a.bookingId}`),
                await S.prisma.booking.update({
                  where: { id: a.bookingId },
                  data: {
                    status: 'BOOKING_FAILED',
                    paymentStatus: 'FAILED',
                    notes: 'Payment failed - automatically cleaned up',
                  },
                }),
                await S.prisma.groomerAvailability.updateMany({
                  where: { bookingId: a.bookingId },
                  data: { isBooked: !1, bookingId: null, isAvailable: !0 },
                }),
                console.log(`[Webhook] Released time slots for failed booking ${a.bookingId}`))
              : console.log(
                  `[Webhook] Booking ${a.bookingId} in status ${e.status} - no cleanup needed`
                )
          }
        } else console.warn(`[Webhook] Payment record not found for ${e}`)
        console.log(`[Webhook] Payment failure processed: ${e}`)
      } catch (e) {
        throw (console.error('[Webhook] Error handling payment failure:', e), e)
      }
    }
    async function L(e, o, t) {
      try {
        if (!e)
          return void console.error(
            '[Webhook] Cannot process payment cancellation without paymentId'
          )
        if (
          (console.log(
            `[Webhook] Processing payment cancellation for ${e}, TX: ${o}, Partial: ${t}`
          ),
          !t)
        )
          try {
            ;(await O.workerApiClient.executePaymentCleanup({ paymentId: e }),
              console.log(`[Webhook] Executed immediate cleanup for cancelled payment: ${e}`))
          } catch (e) {
            console.error('[Webhook] Failed to execute immediate cleanup:', e)
          }
        if (await S.prisma.payment.findUnique({ where: { paymentId: e } })) {
          let a = await S.prisma.payment.update({
            where: { paymentId: e },
            data: {
              status: t ? 'PARTIAL_CANCELLED' : 'CANCELLED',
              cancelledAt: new Date(),
              pgTxId: o,
            },
          })
          !t &&
            a.bookingId &&
            (await S.prisma.booking.update({
              where: { id: a.bookingId },
              data: {
                status: 'SERVICE_CANCELLED',
                cancelledAt: new Date(),
                cancellationReason: 'Payment cancelled',
              },
            }),
            await S.prisma.groomerAvailability.updateMany({
              where: { bookingId: a.bookingId },
              data: { isBooked: !1, bookingId: null, isAvailable: !0 },
            }),
            console.log(`[Webhook] Released time slots for cancelled booking ${a.bookingId}`))
        } else console.warn(`[Webhook] Payment record not found for ${e}`)
        console.log(`[Webhook] Payment cancellation processed: ${e}`)
      } catch (e) {
        throw (console.error('[Webhook] Error handling payment cancellation:', e), e)
      }
    }
    async function B(e, o) {
      try {
        ;(console.log(`[Webhook] Processing payment ready for ${e}, TX: ${o}`),
          (await S.prisma.payment.findUnique({ where: { paymentId: e } }))
            ? await S.prisma.payment.update({
                where: { paymentId: e },
                data: { status: 'PENDING', pgTxId: o },
              })
            : console.warn(`[Webhook] Payment record not found for ${e}`),
          console.log(`[Webhook] Payment ready processed: ${e}`))
      } catch (e) {
        throw (console.error('[Webhook] Error handling payment ready:', e), e)
      }
    }
    async function V(e) {
      try {
        console.log(`[Webhook] Sending groomer notification for booking ${e}`)
        let o = await S.prisma.booking.findUnique({
          where: { id: e },
          include: {
            customer: { select: { name: !0, email: !0 } },
            groomer: { select: { id: !0, name: !0 } },
            bookingPets: { include: { pet: { select: { name: !0 } } } },
          },
        })
        if (!o) return void console.error(`[Webhook] Booking not found: ${e}`)
        let t = o.bookingPets.map((e) => e.pet.name),
          a = {
            bookingId: o.id,
            bookingNumber: o.bookingNumber,
            customerName: o.customer.name || o.customer.email,
            groomerName: o.groomer?.name || '미용사',
            serviceDate: o.serviceDate,
            serviceTime: o.serviceTime,
            petNames: t,
            totalPrice: o.totalPrice,
          }
        if (o.groomerId)
          (await D.BookingNotificationService.notifyGroomerFirstPaymentCompleted(o.groomerId, a))
            ? console.log(
                `[Webhook] Successfully sent notification to assigned groomer: ${o.groomerId}`
              )
            : console.warn(
                `[Webhook] Failed to send notification to assigned groomer: ${o.groomerId}`
              )
        else {
          let e = await D.BookingNotificationService.notifyAllGroomersFirstPaymentCompleted(a)
          console.log(
            `[Webhook] Sent notifications to all groomers: ${e.successCount} success, ${e.failureCount} failed`
          )
        }
      } catch (e) {
        throw (console.error('[Webhook] Error sending groomer notification:', e), e)
      }
    }
    async function H(e) {
      try {
        console.log(`[Webhook] Sending groomer additional payment notification for booking ${e}`)
        let o = await S.prisma.booking.findUnique({
          where: { id: e },
          include: {
            customer: { select: { name: !0, email: !0 } },
            groomer: { select: { id: !0, name: !0 } },
            bookingPets: { include: { pet: { select: { name: !0 } } } },
          },
        })
        if (!o) return void console.error(`[Webhook] Booking not found: ${e}`)
        if (!o.groomerId) return void console.log(`[Webhook] No groomer assigned for booking ${e}`)
        let t = o.bookingPets.map((e) => e.pet.name),
          a = {
            bookingId: o.id,
            bookingNumber: o.bookingNumber,
            customerName: o.customer.name || o.customer.email,
            groomerName: o.groomer?.name || '미용사',
            serviceDate: o.serviceDate,
            serviceTime: o.serviceTime,
            petNames: t,
            totalPrice: o.totalPrice,
            totalAdditionalAmount: o.additionalCharges || 0,
          }
        ;(await D.BookingNotificationService.notifyGroomerAdditionalPaymentCompleted(
          o.groomerId,
          a
        ))
          ? console.log(
              `[Webhook] Successfully sent additional payment notification to groomer: ${o.groomerId}`
            )
          : console.warn(
              `[Webhook] Failed to send additional payment notification to groomer: ${o.groomerId}`
            )
      } catch (e) {
        throw (
          console.error('[Webhook] Error sending groomer additional payment notification:', e),
          e
        )
      }
    }
    e.s(['POST', () => U, 'runtime', 0, 'nodejs'], 330956)
    var G = e.i(330956)
    let q = new o.AppRouteRouteModule({
        definition: {
          kind: t.RouteKind.APP_ROUTE,
          page: '/api/v1/webhooks/portone/route',
          pathname: '/api/v1/webhooks/portone',
          filename: 'route',
          bundlePath: '',
        },
        distDir: '.next',
        relativeProjectDir: '',
        resolvedPagePath: '[project]/src/app/api/v1/webhooks/portone/route.ts',
        nextConfigOutput: 'standalone',
        userland: G,
      }),
      { workAsyncStorage: j, workUnitAsyncStorage: K, serverHooks: X } = q
    function Y() {
      return (0, a.patchFetch)({ workAsyncStorage: j, workUnitAsyncStorage: K })
    }
    async function z(e, o, a) {
      q.isDev && (0, n.addRequestMeta)(e, 'devRequestTimingInternalsEnd', process.hrtime.bigint())
      let k = '/api/v1/webhooks/portone/route'
      k = k.replace(/\/index$/, '') || '/'
      let y = await q.prepare(e, o, { srcPage: k, multiZoneDraftMode: !1 })
      if (!y)
        return (
          (o.statusCode = 400),
          o.end('Bad Request'),
          null == a.waitUntil || a.waitUntil.call(a, Promise.resolve()),
          null
        )
      let {
          buildId: E,
          params: I,
          nextConfig: v,
          parsedUrl: A,
          isDraftMode: R,
          prerenderManifest: P,
          routerServerContext: T,
          isOnDemandRevalidate: N,
          revalidateOnlyGenerated: C,
          resolvedPathname: W,
          clientReferenceManifest: $,
          serverActionsManifest: S,
        } = y,
        O = (0, l.normalizeAppPath)(k),
        D = !!(P.dynamicRoutes[O] || P.routes[W]),
        _ = async () => (
          (null == T ? void 0 : T.render404)
            ? await T.render404(e, o, A, !1)
            : o.end('This page could not be found'),
          null
        )
      if (D && !R) {
        let e = !!P.routes[W],
          o = P.dynamicRoutes[O]
        if (o && !1 === o.fallback && !e) {
          if (v.experimental.adapterPath) return await _()
          throw new f.NoFallbackError()
        }
      }
      let x = null
      !D || q.isDev || R || (x = '/index' === (x = W) ? '/' : x)
      let U = !0 === q.isDev || !D,
        M = D && !U
      S &&
        $ &&
        (0, i.setReferenceManifestsSingleton)({
          page: k,
          clientReferenceManifest: $,
          serverActionsManifest: S,
          serverModuleMap: (0, s.createServerModuleMap)({ serverActionsManifest: S }),
        })
      let F = e.method || 'GET',
        L = (0, r.getTracer)(),
        B = L.getActiveScopeSpan(),
        V = {
          params: I,
          prerenderManifest: P,
          renderOpts: {
            experimental: { authInterrupts: !!v.experimental.authInterrupts },
            cacheComponents: !!v.cacheComponents,
            supportsDynamicResponse: U,
            incrementalCache: (0, n.getRequestMeta)(e, 'incrementalCache'),
            cacheLifeProfiles: v.cacheLife,
            waitUntil: a.waitUntil,
            onClose: (e) => {
              o.on('close', e)
            },
            onAfterTaskError: void 0,
            onInstrumentationRequestError: (o, t, a) => q.onRequestError(e, o, a, T),
          },
          sharedContext: { buildId: E },
        },
        H = new c.NodeNextRequest(e),
        G = new c.NodeNextResponse(o),
        j = d.NextRequestAdapter.fromNodeNextRequest(H, (0, d.signalFromNodeResponse)(o))
      try {
        let i = async (e) =>
            q.handle(j, V).finally(() => {
              if (!e) return
              e.setAttributes({ 'http.status_code': o.statusCode, 'next.rsc': !1 })
              let t = L.getRootSpanAttributes()
              if (!t) return
              if (t.get('next.span_type') !== u.BaseServerSpan.handleRequest)
                return void console.warn(
                  `Unexpected root span type '${t.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`
                )
              let a = t.get('next.route')
              if (a) {
                let o = `${F} ${a}`
                ;(e.setAttributes({ 'next.route': a, 'http.route': a, 'next.span_name': o }),
                  e.updateName(o))
              } else e.updateName(`${F} ${k}`)
            }),
          s = !!(0, n.getRequestMeta)(e, 'minimalMode'),
          l = async (n) => {
            var r, l
            let c = async ({ previousCacheEntry: t }) => {
                try {
                  if (!s && N && C && !t)
                    return (
                      (o.statusCode = 404),
                      o.setHeader('x-nextjs-cache', 'REVALIDATED'),
                      o.end('This page could not be found'),
                      null
                    )
                  let r = await i(n)
                  e.fetchMetrics = V.renderOpts.fetchMetrics
                  let l = V.renderOpts.pendingWaitUntil
                  l && a.waitUntil && (a.waitUntil(l), (l = void 0))
                  let c = V.renderOpts.collectedTags
                  if (!D)
                    return (await (0, h.sendResponse)(H, G, r, V.renderOpts.pendingWaitUntil), null)
                  {
                    let e = await r.blob(),
                      o = (0, g.toNodeOutgoingHttpHeaders)(r.headers)
                    ;(c && (o[b.NEXT_CACHE_TAGS_HEADER] = c),
                      !o['content-type'] && e.type && (o['content-type'] = e.type))
                    let t =
                        void 0 !== V.renderOpts.collectedRevalidate &&
                        !(V.renderOpts.collectedRevalidate >= b.INFINITE_CACHE) &&
                        V.renderOpts.collectedRevalidate,
                      a =
                        void 0 === V.renderOpts.collectedExpire ||
                        V.renderOpts.collectedExpire >= b.INFINITE_CACHE
                          ? void 0
                          : V.renderOpts.collectedExpire
                    return {
                      value: {
                        kind: w.CachedRouteKind.APP_ROUTE,
                        status: r.status,
                        body: Buffer.from(await e.arrayBuffer()),
                        headers: o,
                      },
                      cacheControl: { revalidate: t, expire: a },
                    }
                  }
                } catch (o) {
                  throw (
                    (null == t ? void 0 : t.isStale) &&
                      (await q.onRequestError(
                        e,
                        o,
                        {
                          routerKind: 'App Router',
                          routePath: k,
                          routeType: 'route',
                          revalidateReason: (0, p.getRevalidateReason)({
                            isStaticGeneration: M,
                            isOnDemandRevalidate: N,
                          }),
                        },
                        T
                      )),
                    o
                  )
                }
              },
              d = await q.handleResponse({
                req: e,
                nextConfig: v,
                cacheKey: x,
                routeKind: t.RouteKind.APP_ROUTE,
                isFallback: !1,
                prerenderManifest: P,
                isRoutePPREnabled: !1,
                isOnDemandRevalidate: N,
                revalidateOnlyGenerated: C,
                responseGenerator: c,
                waitUntil: a.waitUntil,
                isMinimalMode: s,
              })
            if (!D) return null
            if (
              (null == d || null == (r = d.value) ? void 0 : r.kind) !== w.CachedRouteKind.APP_ROUTE
            )
              throw Object.defineProperty(
                Error(
                  `Invariant: app-route received invalid cache entry ${null == d || null == (l = d.value) ? void 0 : l.kind}`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E701', enumerable: !1, configurable: !0 }
              )
            ;(s ||
              o.setHeader(
                'x-nextjs-cache',
                N ? 'REVALIDATED' : d.isMiss ? 'MISS' : d.isStale ? 'STALE' : 'HIT'
              ),
              R &&
                o.setHeader(
                  'Cache-Control',
                  'private, no-cache, no-store, max-age=0, must-revalidate'
                ))
            let u = (0, g.fromNodeOutgoingHttpHeaders)(d.value.headers)
            return (
              (s && D) || u.delete(b.NEXT_CACHE_TAGS_HEADER),
              !d.cacheControl ||
                o.getHeader('Cache-Control') ||
                u.get('Cache-Control') ||
                u.set('Cache-Control', (0, m.getCacheControlHeader)(d.cacheControl)),
              await (0, h.sendResponse)(
                H,
                G,
                new Response(d.value.body, { headers: u, status: d.value.status || 200 })
              ),
              null
            )
          }
        B
          ? await l(B)
          : await L.withPropagatedContext(e.headers, () =>
              L.trace(
                u.BaseServerSpan.handleRequest,
                {
                  spanName: `${F} ${k}`,
                  kind: r.SpanKind.SERVER,
                  attributes: { 'http.method': F, 'http.target': e.url },
                },
                l
              )
            )
      } catch (o) {
        if (
          (o instanceof f.NoFallbackError ||
            (await q.onRequestError(e, o, {
              routerKind: 'App Router',
              routePath: O,
              routeType: 'route',
              revalidateReason: (0, p.getRevalidateReason)({
                isStaticGeneration: M,
                isOnDemandRevalidate: N,
              }),
            })),
          D)
        )
          throw o
        return (await (0, h.sendResponse)(H, G, new Response(null, { status: 500 })), null)
      }
    }
    e.s(
      [
        'handler',
        () => z,
        'patchFetch',
        () => Y,
        'routeModule',
        () => q,
        'serverHooks',
        () => X,
        'workAsyncStorage',
        () => j,
        'workUnitAsyncStorage',
        () => K,
      ],
      123987
    )
  },
]

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_86227902.js.map
