module.exports = [
  471428,
  (e) => {
    'use strict'
    let t, r
    var a = e.i(747909),
      n = e.i(174017),
      o = e.i(996250),
      i = e.i(759756),
      s = e.i(561916),
      l = e.i(114444),
      u = e.i(837092),
      d = e.i(869741),
      c = e.i(316795),
      p = e.i(487718),
      m = e.i(995169),
      R = e.i(47587),
      N = e.i(666012),
      h = e.i(570101),
      E = e.i(626937),
      f = e.i(10372),
      g = e.i(193695)
    e.i(52474)
    var y = e.i(600220),
      O = e.i(89171),
      w = e.i(493458),
      I = e.i(469719),
      P = e.i(79832),
      _ = e.i(657446),
      v = e.i(378725),
      A = e.i(398163),
      T = e.i(666680),
      x = e.i(547499)
    let D = I.z.object({
      bookingId: I.z.string().min(1, '예약 ID는 필수입니다'),
      amount: I.z.number().positive('금액은 양수여야 합니다'),
      orderName: I.z.string().min(1, '주문명은 필수입니다'),
    })
    async function S(e) {
      try {
        let a = await P.default.api.getSession({ headers: await (0, w.headers)() })
        if (!a?.user) return O.NextResponse.json({ error: '인증이 필요합니다' }, { status: 401 })
        let n = await e.json(),
          { bookingId: o, amount: i, orderName: s } = D.parse(n),
          l = new Date(Date.now() - 18e5),
          {
            paymentId: u,
            isNewPayment: d,
            user: c,
          } = await _.prisma.$transaction(
            async (e) => {
              let n,
                u,
                d = await e.user.findUnique({
                  where: { id: a.user.id },
                  select: { id: !0, email: !0, name: !0, phoneNumber: !0 },
                })
              if (!d) throw Error('USER_NOT_FOUND')
              let c = await e.booking.findUnique({
                where: { id: o },
                include: {
                  bookingPets: { include: { services: { include: { service: !0 } } } },
                  groomer: { include: { groomerProfile: !0 } },
                },
              })
              if (!c) throw Error('BOOKING_NOT_FOUND')
              if (c.customerId !== a.user.id) throw Error('FORBIDDEN')
              if (
                ![
                  _.BookingStatus.FIRST_PAYMENT_PENDING,
                  _.BookingStatus.ADDITIONAL_PAYMENT_PENDING,
                ].includes(c.status)
              )
                throw Error(`INVALID_BOOKING_STATUS:${c.status}`)
              if (c.groomerId) {
                if (!c.groomer) throw Error('GROOMER_NOT_FOUND')
                if (!c.groomer.groomerProfile?.isActive) throw Error('GROOMER_INACTIVE')
                if (c.groomer.role !== _.UserRole.GROOMER) throw Error('INVALID_GROOMER')
              }
              switch (c.status) {
                case _.BookingStatus.FIRST_PAYMENT_PENDING:
                  ;((n = c.basePrice), (u = '예약금'))
                  break
                case _.BookingStatus.ADDITIONAL_PAYMENT_PENDING:
                  ;((n = c.additionalCharges), (u = '잔금'))
                  break
                default:
                  ;((n = c.bookingPets.reduce(
                    (e, t) => e + t.services.reduce((e, t) => e + t.servicePrice, 0),
                    0
                  )),
                    (u = '전체 금액'))
              }
              if (n !== i) throw Error(`AMOUNT_MISMATCH:${u}:${n}:${i}`)
              let p = await e.payment.findFirst({
                where: { bookingId: o, status: _.PaymentStatus.PENDING, createdAt: { gt: l } },
                orderBy: { createdAt: 'desc' },
              })
              if (
                (await e.payment.updateMany({
                  where: { bookingId: o, status: _.PaymentStatus.PENDING, createdAt: { lte: l } },
                  data: { status: _.PaymentStatus.EXPIRED },
                }),
                p)
              )
                return (
                  console.log(`[Payment Initialize] Reusing existing payment: ${p.paymentId}`),
                  { paymentId: p.paymentId, isNewPayment: !1, user: d }
                )
              {
                let a = `payment-${Date.now()}-${(function (e = 21) {
                  var a
                  ;((a = e |= 0),
                    !t || t.length < a
                      ? ((t = Buffer.allocUnsafe(128 * a)), T.webcrypto.getRandomValues(t), (r = 0))
                      : r + a > t.length && (T.webcrypto.getRandomValues(t), (r = 0)),
                    (r += a))
                  let n = ''
                  for (let a = r - e; a < r; a++)
                    n += 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'[
                      63 & t[a]
                    ]
                  return n
                })(10)}`
                return (
                  console.log(`[Payment Initialize] Creating new payment: ${a}`),
                  await e.payment.create({
                    data: {
                      paymentId: a,
                      status: _.PaymentStatus.PENDING,
                      amount: i,
                      currency: 'KRW',
                      customerId: d.id,
                      bookingId: o,
                      orderName: s,
                      method: 'PENDING',
                    },
                  }),
                  { paymentId: a, isNewPayment: !0, user: d }
                )
              }
            },
            {
              isolationLevel: _.Prisma.TransactionIsolationLevel.Serializable,
              maxWait: 5e3,
              timeout: 1e4,
            }
          )
        if (d) {
          let e = Date.now()
          try {
            ;(await (0, v.preRegisterPayment)({
              paymentId: u,
              totalAmount: i,
              currency: 'KRW',
              orderName: s,
            }),
              console.log(`[Payment Initialize] Pre-registration successful for ${u}`))
          } catch (e) {
            console.error('[Payment Initialize] Pre-register failed:', e)
          }
          try {
            let t = Date.now() - e,
              r = Math.max(3e5 - t, 6e4)
            ;(await A.workerApiClient.schedulePaymentCleanup({
              paymentId: u,
              bookingId: o,
              delayMs: r,
            }),
              console.log(
                `[Payment Initialize] Scheduled cleanup job for payment: ${u} (delay: ${r}ms)`
              ))
          } catch (e) {
            throw (
              console.error('[Payment Initialize] Failed to schedule cleanup job:', e),
              Error('Failed to schedule payment cleanup - operation aborted')
            )
          }
        }
        let p = x.env.PORTONE_CHANNEL_KEY || x.env.NEXT_PUBLIC_PORTONE_CHANNEL_KEY,
          m = x.env.PORTONE_STORE_ID || x.env.NEXT_PUBLIC_PORTONE_STORE_ID
        if (!p || !m)
          return O.NextResponse.json({ error: 'PortOne 설정이 올바르지 않습니다' }, { status: 500 })
        return O.NextResponse.json({
          success: !0,
          paymentId: u,
          amount: i,
          orderName: s,
          customerName: c.name || '고객',
          customerEmail: c.email || '',
          customerPhone: c.phoneNumber || '',
          channelKey: p,
          storeId: m,
        })
      } catch (e) {
        if ((console.error('[Payment Initialize] Error:', e), e instanceof I.z.ZodError))
          return O.NextResponse.json({ error: '잘못된 요청 데이터입니다' }, { status: 400 })
        if (e instanceof Error) {
          let t = e.message
          if ('USER_NOT_FOUND' === t)
            return O.NextResponse.json({ error: '사용자 정보를 찾을 수 없습니다' }, { status: 404 })
          if ('BOOKING_NOT_FOUND' === t)
            return O.NextResponse.json({ error: '예약 정보를 찾을 수 없습니다' }, { status: 404 })
          if ('FORBIDDEN' === t)
            return O.NextResponse.json({ error: '접근 권한이 없습니다' }, { status: 403 })
          if (t.startsWith('INVALID_BOOKING_STATUS:')) {
            let e = t.split(':')[1]
            return O.NextResponse.json(
              { error: '결제할 수 없는 예약 상태입니다', currentStatus: e },
              { status: 400 }
            )
          }
          if ('GROOMER_NOT_FOUND' === t)
            return O.NextResponse.json({ error: '그루머 정보를 찾을 수 없습니다' }, { status: 404 })
          if ('GROOMER_INACTIVE' === t)
            return O.NextResponse.json(
              { error: '선택하신 그루머는 현재 예약을 받을 수 없는 상태입니다' },
              { status: 400 }
            )
          if ('INVALID_GROOMER' === t)
            return O.NextResponse.json({ error: '유효하지 않은 그루머입니다' }, { status: 400 })
          if (t.startsWith('AMOUNT_MISMATCH:')) {
            let [, e, r, a] = t.split(':')
            return O.NextResponse.json(
              {
                error: `${e} 결제 금액이 일치하지 않습니다. 예상: ${Number(r).toLocaleString('ko-KR')}원, 요청: ${Number(a).toLocaleString('ko-KR')}원`,
                expectedAmount: Number(r),
                requestedAmount: Number(a),
                paymentType: e,
              },
              { status: 400 }
            )
          }
        }
        return O.NextResponse.json({ error: '결제 초기화 중 오류가 발생했습니다' }, { status: 500 })
      }
    }
    e.s(['POST', () => S, 'initializePaymentSchema', 0, D], 947961)
    var C = e.i(947961)
    let b = new a.AppRouteRouteModule({
        definition: {
          kind: n.RouteKind.APP_ROUTE,
          page: '/api/payments/initialize/route',
          pathname: '/api/payments/initialize',
          filename: 'route',
          bundlePath: '',
        },
        distDir: '.next',
        relativeProjectDir: '',
        resolvedPagePath: '[project]/src/app/api/payments/initialize/route.ts',
        nextConfigOutput: 'standalone',
        userland: C,
      }),
      { workAsyncStorage: M, workUnitAsyncStorage: U, serverHooks: k } = b
    function j() {
      return (0, o.patchFetch)({ workAsyncStorage: M, workUnitAsyncStorage: U })
    }
    async function $(e, t, r) {
      b.isDev && (0, i.addRequestMeta)(e, 'devRequestTimingInternalsEnd', process.hrtime.bigint())
      let a = '/api/payments/initialize/route'
      a = a.replace(/\/index$/, '') || '/'
      let o = await b.prepare(e, t, { srcPage: a, multiZoneDraftMode: !1 })
      if (!o)
        return (
          (t.statusCode = 400),
          t.end('Bad Request'),
          null == r.waitUntil || r.waitUntil.call(r, Promise.resolve()),
          null
        )
      let {
          buildId: O,
          params: w,
          nextConfig: I,
          parsedUrl: P,
          isDraftMode: _,
          prerenderManifest: v,
          routerServerContext: A,
          isOnDemandRevalidate: T,
          revalidateOnlyGenerated: x,
          resolvedPathname: D,
          clientReferenceManifest: S,
          serverActionsManifest: C,
        } = o,
        M = (0, d.normalizeAppPath)(a),
        U = !!(v.dynamicRoutes[M] || v.routes[D]),
        k = async () => (
          (null == A ? void 0 : A.render404)
            ? await A.render404(e, t, P, !1)
            : t.end('This page could not be found'),
          null
        )
      if (U && !_) {
        let e = !!v.routes[D],
          t = v.dynamicRoutes[M]
        if (t && !1 === t.fallback && !e) {
          if (I.experimental.adapterPath) return await k()
          throw new g.NoFallbackError()
        }
      }
      let j = null
      !U || b.isDev || _ || (j = '/index' === (j = D) ? '/' : j)
      let $ = !0 === b.isDev || !U,
        G = U && !$
      C &&
        S &&
        (0, l.setReferenceManifestsSingleton)({
          page: a,
          clientReferenceManifest: S,
          serverActionsManifest: C,
          serverModuleMap: (0, u.createServerModuleMap)({ serverActionsManifest: C }),
        })
      let F = e.method || 'GET',
        H = (0, s.getTracer)(),
        z = H.getActiveScopeSpan(),
        B = {
          params: w,
          prerenderManifest: v,
          renderOpts: {
            experimental: { authInterrupts: !!I.experimental.authInterrupts },
            cacheComponents: !!I.cacheComponents,
            supportsDynamicResponse: $,
            incrementalCache: (0, i.getRequestMeta)(e, 'incrementalCache'),
            cacheLifeProfiles: I.cacheLife,
            waitUntil: r.waitUntil,
            onClose: (e) => {
              t.on('close', e)
            },
            onAfterTaskError: void 0,
            onInstrumentationRequestError: (t, r, a) => b.onRequestError(e, t, a, A),
          },
          sharedContext: { buildId: O },
        },
        L = new c.NodeNextRequest(e),
        K = new c.NodeNextResponse(t),
        q = p.NextRequestAdapter.fromNodeNextRequest(L, (0, p.signalFromNodeResponse)(t))
      try {
        let o = async (e) =>
            b.handle(q, B).finally(() => {
              if (!e) return
              e.setAttributes({ 'http.status_code': t.statusCode, 'next.rsc': !1 })
              let r = H.getRootSpanAttributes()
              if (!r) return
              if (r.get('next.span_type') !== m.BaseServerSpan.handleRequest)
                return void console.warn(
                  `Unexpected root span type '${r.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`
                )
              let n = r.get('next.route')
              if (n) {
                let t = `${F} ${n}`
                ;(e.setAttributes({ 'next.route': n, 'http.route': n, 'next.span_name': t }),
                  e.updateName(t))
              } else e.updateName(`${F} ${a}`)
            }),
          l = !!(0, i.getRequestMeta)(e, 'minimalMode'),
          u = async (i) => {
            var s, u
            let d = async ({ previousCacheEntry: n }) => {
                try {
                  if (!l && T && x && !n)
                    return (
                      (t.statusCode = 404),
                      t.setHeader('x-nextjs-cache', 'REVALIDATED'),
                      t.end('This page could not be found'),
                      null
                    )
                  let a = await o(i)
                  e.fetchMetrics = B.renderOpts.fetchMetrics
                  let s = B.renderOpts.pendingWaitUntil
                  s && r.waitUntil && (r.waitUntil(s), (s = void 0))
                  let u = B.renderOpts.collectedTags
                  if (!U)
                    return (await (0, N.sendResponse)(L, K, a, B.renderOpts.pendingWaitUntil), null)
                  {
                    let e = await a.blob(),
                      t = (0, h.toNodeOutgoingHttpHeaders)(a.headers)
                    ;(u && (t[f.NEXT_CACHE_TAGS_HEADER] = u),
                      !t['content-type'] && e.type && (t['content-type'] = e.type))
                    let r =
                        void 0 !== B.renderOpts.collectedRevalidate &&
                        !(B.renderOpts.collectedRevalidate >= f.INFINITE_CACHE) &&
                        B.renderOpts.collectedRevalidate,
                      n =
                        void 0 === B.renderOpts.collectedExpire ||
                        B.renderOpts.collectedExpire >= f.INFINITE_CACHE
                          ? void 0
                          : B.renderOpts.collectedExpire
                    return {
                      value: {
                        kind: y.CachedRouteKind.APP_ROUTE,
                        status: a.status,
                        body: Buffer.from(await e.arrayBuffer()),
                        headers: t,
                      },
                      cacheControl: { revalidate: r, expire: n },
                    }
                  }
                } catch (t) {
                  throw (
                    (null == n ? void 0 : n.isStale) &&
                      (await b.onRequestError(
                        e,
                        t,
                        {
                          routerKind: 'App Router',
                          routePath: a,
                          routeType: 'route',
                          revalidateReason: (0, R.getRevalidateReason)({
                            isStaticGeneration: G,
                            isOnDemandRevalidate: T,
                          }),
                        },
                        A
                      )),
                    t
                  )
                }
              },
              c = await b.handleResponse({
                req: e,
                nextConfig: I,
                cacheKey: j,
                routeKind: n.RouteKind.APP_ROUTE,
                isFallback: !1,
                prerenderManifest: v,
                isRoutePPREnabled: !1,
                isOnDemandRevalidate: T,
                revalidateOnlyGenerated: x,
                responseGenerator: d,
                waitUntil: r.waitUntil,
                isMinimalMode: l,
              })
            if (!U) return null
            if (
              (null == c || null == (s = c.value) ? void 0 : s.kind) !== y.CachedRouteKind.APP_ROUTE
            )
              throw Object.defineProperty(
                Error(
                  `Invariant: app-route received invalid cache entry ${null == c || null == (u = c.value) ? void 0 : u.kind}`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E701', enumerable: !1, configurable: !0 }
              )
            ;(l ||
              t.setHeader(
                'x-nextjs-cache',
                T ? 'REVALIDATED' : c.isMiss ? 'MISS' : c.isStale ? 'STALE' : 'HIT'
              ),
              _ &&
                t.setHeader(
                  'Cache-Control',
                  'private, no-cache, no-store, max-age=0, must-revalidate'
                ))
            let p = (0, h.fromNodeOutgoingHttpHeaders)(c.value.headers)
            return (
              (l && U) || p.delete(f.NEXT_CACHE_TAGS_HEADER),
              !c.cacheControl ||
                t.getHeader('Cache-Control') ||
                p.get('Cache-Control') ||
                p.set('Cache-Control', (0, E.getCacheControlHeader)(c.cacheControl)),
              await (0, N.sendResponse)(
                L,
                K,
                new Response(c.value.body, { headers: p, status: c.value.status || 200 })
              ),
              null
            )
          }
        z
          ? await u(z)
          : await H.withPropagatedContext(e.headers, () =>
              H.trace(
                m.BaseServerSpan.handleRequest,
                {
                  spanName: `${F} ${a}`,
                  kind: s.SpanKind.SERVER,
                  attributes: { 'http.method': F, 'http.target': e.url },
                },
                u
              )
            )
      } catch (t) {
        if (
          (t instanceof g.NoFallbackError ||
            (await b.onRequestError(e, t, {
              routerKind: 'App Router',
              routePath: M,
              routeType: 'route',
              revalidateReason: (0, R.getRevalidateReason)({
                isStaticGeneration: G,
                isOnDemandRevalidate: T,
              }),
            })),
          U)
        )
          throw t
        return (await (0, N.sendResponse)(L, K, new Response(null, { status: 500 })), null)
      }
    }
    e.s(
      [
        'handler',
        () => $,
        'patchFetch',
        () => j,
        'routeModule',
        () => b,
        'serverHooks',
        () => k,
        'workAsyncStorage',
        () => M,
        'workUnitAsyncStorage',
        () => U,
      ],
      471428
    )
  },
]

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_1dc1bed9.js.map
