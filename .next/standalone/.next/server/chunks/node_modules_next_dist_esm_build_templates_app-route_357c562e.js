module.exports = [
  225859,
  (e) => {
    'use strict'
    var t = e.i(747909),
      r = e.i(174017),
      a = e.i(996250),
      o = e.i(759756),
      n = e.i(561916),
      s = e.i(114444),
      i = e.i(837092),
      l = e.i(869741),
      d = e.i(316795),
      u = e.i(487718),
      c = e.i(995169),
      m = e.i(47587),
      p = e.i(666012),
      h = e.i(570101),
      g = e.i(626937),
      w = e.i(10372),
      E = e.i(193695)
    e.i(52474)
    var f = e.i(600220),
      R = e.i(89171),
      S = e.i(493458),
      P = e.i(79832),
      y = e.i(657446),
      b = e.i(250354),
      I = e.i(528164),
      A = e.i(458325),
      O = e.i(418789),
      D = e.i(905404)
    let N = new (class {
      isRunning = !1
      intervalId = null
      start() {
        console.log(
          'âš ï¸ ì •ì‚° ìŠ¤ì¼€ì¤„ëŸ¬ ìë™ ì‹¤í–‰ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ìœ¼ë¡œë§Œ ì •ì‚°ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.'
        )
      }
      stop() {
        this.isRunning &&
          ((this.isRunning = !1),
          this.intervalId && (clearInterval(this.intervalId), (this.intervalId = null)),
          console.log('ğŸ”´ ì •ì‚° ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€'))
      }
      async checkAndExecuteJobs() {
        console.log('âš ï¸ ì •ì‚° ì‘ì—… ìë™ ì‹¤í–‰ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.')
      }
      async executeJob(e) {
        try {
          let t
          switch (
            (await y.prisma.settlementJob.update({
              where: { id: e.id },
              data: { status: 'RUNNING', executedAt: new Date(), attempts: { increment: 1 } },
            }),
            console.log(`ğŸš€ ì •ì‚° ì‘ì—… ì‹¤í–‰: ${e.jobType} (ID: ${e.id})`),
            e.jobType)
          ) {
            case 'WEEKLY_SETTLEMENT':
              t = await this.processWeeklySettlement(e)
              break
            case 'MANUAL_SETTLEMENT':
              t = await this.processManualSettlement(e)
              break
            case 'RETRY_SETTLEMENT':
              t = await this.processRetrySettlement(e)
              break
            default:
              throw Error(`ì•Œ ìˆ˜ ì—†ëŠ” ì‘ì—… íƒ€ì…: ${e.jobType}`)
          }
          ;(await y.prisma.settlementJob.update({
            where: { id: e.id },
            data: {
              status: 'COMPLETED',
              completedAt: new Date(),
              result: JSON.stringify(t),
              lastError: null,
            },
          }),
            console.log(`âœ… ì •ì‚° ì‘ì—… ì™„ë£Œ: ${e.jobType} (ID: ${e.id})`))
        } catch (r) {
          console.error(`âŒ ì •ì‚° ì‘ì—… ì‹¤íŒ¨: ${e.jobType} (ID: ${e.id})`, r)
          let t = e.attempts < e.maxAttempts
          ;(await y.prisma.settlementJob.update({
            where: { id: e.id },
            data: {
              status: t ? 'PENDING' : 'FAILED',
              lastError: r instanceof Error ? r.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜',
              scheduledAt: t ? new Date(Date.now() + 3e5) : e.scheduledAt,
            },
          }),
            t || console.error(`ğŸ’¥ ì •ì‚° ì‘ì—… ìµœì¢… ì‹¤íŒ¨: ${e.id}`))
        }
      }
      async processWeeklySettlement(e) {
        console.log(`ğŸ“… ì£¼ê°„ ì •ì‚° ì²˜ë¦¬ ì‹œì‘: ${e.id}`)
        let t = (0, A.subWeeks)(new Date(), 1),
          r = (0, b.startOfWeek)(t, { weekStartsOn: 1 }),
          a = (0, I.endOfWeek)(t, { weekStartsOn: 1 }),
          { results: o, summary: n } = await D.SettlementCalculator.processSettlements(r, a, {
            skipExisting: !0,
            dryRun: !1,
          }),
          s = o.map((e) => ({
            groomerId: e.groomerId,
            groomerName: e.groomerName,
            settlementId: e.settlementId,
            netAmount: e.calculation?.netSettlementAmount,
            status: e.status,
            error: e.error,
            portoneTransferId: void 0,
            portoneSettlementId: void 0,
          }))
        return {
          type: 'weekly_settlement',
          period: { start: r, end: a },
          processed: n.total,
          successful: n.successful,
          failed: n.failed,
          results: s,
        }
      }
      async processManualSettlement(e) {
        if (!e.groomerId || !e.periodStartDate || !e.periodEndDate)
          throw Error('ìˆ˜ë™ ì •ì‚°ì— í•„ìš”í•œ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤')
        if (!(await D.SettlementCalculator.fetchActiveGroomers()).find((t) => t.id === e.groomerId))
          throw Error('ë¯¸ìš©ì‚¬ í”„ë¡œí•„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')
        let { results: t } = await D.SettlementCalculator.processSettlements(
            e.periodStartDate,
            e.periodEndDate,
            { skipExisting: !1, dryRun: !1 }
          ),
          r = t.find((t) => t.groomerId === e.groomerId)
        if (!r || 'success' !== r.status) throw Error(r?.error || 'ì •ì‚°í•  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤')
        return {
          type: 'manual_settlement',
          groomerId: e.groomerId,
          groomerName: r.groomerName,
          settlementId: r.settlementId,
          netAmount: r.calculation.netSettlementAmount,
          portoneTransferId: void 0,
          portoneSettlementId: void 0,
        }
      }
      async processRetrySettlement(e) {
        return await this.processManualSettlement(e)
      }
      async calculateAndCreateSettlement(e, t, r, a) {
        let o =
          (await D.SettlementCalculator.fetchBookingsForGroomers([e.id], t, r)).get(e.id) || []
        if (0 === o.length) return null
        let n = D.SettlementCalculator.calculateSettlement(
            o,
            e.groomerProfile?.commissionGrade?.commissionRate || 60,
            e.groomerProfile?.taxRate || 0
          ),
          s = {}
        return (
          (0, O.isPortOneEnabled)() &&
            (s = await this.processPortOneSettlement(e, t, r, o)).error &&
            console.warn(`PortOne ì •ì‚° ì²˜ë¦¬ ì‹¤íŒ¨: ${s.error}`),
          await y.prisma.$transaction(async (i) => {
            let l = await i.groomerSettlement.create({
              data: {
                groomerId: e.id,
                groomerProfileId: e.groomerProfile.id,
                settlementDate: new Date(),
                periodStartDate: t,
                periodEndDate: r,
                totalRevenue: n.totalRevenue,
                commissionRate: n.commissionRate,
                commissionAmount: n.platformCommission,
                taxAmount: n.taxAmount,
                netSettlementAmount: n.netSettlementAmount,
                status: s.portoneSettlementId ? 'READY_FOR_PAYOUT' : 'CALCULATED',
                bookingCount: n.bookingCount,
                notes: a ? 'ê´€ë¦¬ì ìˆ˜ë™ ì •ì‚°' : 'ìë™ ì •ì‚°',
                portoneTransferId: s.portoneTransferId,
                portoneSettlementId: s.portoneSettlementId,
              },
            })
            for (let t of o) {
              let r = t.totalPrice * (n.commissionRate / 100),
                a = n.taxAmount > 0 ? t.totalPrice * (n.taxAmount / n.totalRevenue) : 0,
                o = t.totalPrice - r - a
              await i.groomerSettlementDetail.create({
                data: {
                  settlementId: l.id,
                  groomerProfileId: e.groomerProfile.id,
                  bookingId: t.id,
                  bookingDate: t.completedAt,
                  serviceAmount: t.totalPrice,
                  commissionRate: n.commissionRate,
                  commissionAmount: r,
                  taxAmount: a,
                  netAmount: o,
                },
              })
            }
            return l
          })
        )
      }
      async processPortOneSettlement(e, t, r, a) {
        try {
          if (!(0, O.isPortOneEnabled)()) return { error: 'PortOne ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ' }
          let o = (0, O.getPortOneClient)(),
            n = []
          for (let t of a)
            try {
              let r = t.payments?.[0]
              if (!r?.paymentId) {
                console.warn(`ì˜ˆì•½ ${t.bookingNumber}ì— ê²°ì œ ì •ë³´ê°€ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤`)
                continue
              }
              let a = {
                  partnerId: e.portonePartnerId,
                  contractId: e.portoneContractId ?? void 0,
                  memo: `ë¯¸ìš© ì„œë¹„ìŠ¤ ì •ì‚° - ì˜ˆì•½ ${t.bookingNumber}`,
                  orderDetail: {
                    orderId: t.bookingNumber,
                    orderName: `ë¯¸ìš© ì„œë¹„ìŠ¤ ì˜ˆì•½ #${t.bookingNumber}`,
                  },
                  transferAmount: t.totalPrice,
                },
                s = await o.createOrderTransfer(a)
              ;(n.push(s.id),
                console.log(`âœ… PortOne ì •ì‚° ê±´ ìƒì„±: ${s.id} (ì˜ˆì•½: ${t.bookingNumber})`))
            } catch (e) {
              console.error(`âŒ PortOne ì •ì‚° ê±´ ìƒì„± ì‹¤íŒ¨ (ì˜ˆì•½: ${t.bookingNumber}):`, e)
            }
          if (0 === n.length) return { error: 'ìƒì„±ëœ PortOne ì •ì‚° ê±´ì´ ì—†ìŒ' }
          let s = (
            await o.listPartnerSettlements({
              partnerIds: [e.portonePartnerId],
              settlementDates: { from: o.formatDate(t), until: o.formatDate(r) },
            })
          ).items.find(
            (t) => t.partnerId === e.portonePartnerId && n.some((e) => t.transferIds.includes(e))
          )
          return { portoneTransferId: n[0], portoneSettlementId: s?.id }
        } catch (e) {
          return (
            console.error('PortOne ì •ì‚° ì²˜ë¦¬ ì‹¤íŒ¨:', e),
            { error: e instanceof Error ? e.message : 'ì•Œ ìˆ˜ ì—†ëŠ” PortOne ì˜¤ë¥˜' }
          )
        }
      }
      async syncPortOneSettlementStatus(e) {
        try {
          if (!(0, O.isPortOneEnabled)())
            return { success: !1, error: 'PortOne ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ' }
          let t = await y.prisma.groomerSettlement.findUnique({ where: { id: e } })
          if (!t?.portoneSettlementId) return { success: !1, error: 'PortOne ì •ì‚° IDê°€ ì—†ìŒ' }
          let r = (0, O.getPortOneClient)(),
            a = await r.getPartnerSettlement(t.portoneSettlementId),
            o = t.status
          switch (a.status) {
            case 'PAYOUT_SCHEDULED':
            case 'PAYOUT_PREPARED':
            case 'IN_PAYOUT':
              o = 'PROCESSING'
              break
            case 'PAID_OUT':
              o = 'PAID'
              break
            case 'CANCELLED':
              o = 'CANCELLED'
              break
            case 'PAYOUT_SCHEDULED':
              o = 'READY_FOR_PAYOUT'
          }
          return (
            o !== t.status &&
              (await y.prisma.groomerSettlement.update({
                where: { id: e },
                data: { status: o, paidAt: 'PAID_OUT' === a.status ? new Date() : t.paidAt },
              })),
            { success: !0, status: a.status }
          )
        } catch (t) {
          return (
            console.error(`PortOne ì •ì‚° ìƒíƒœ ë™ê¸°í™” ì‹¤íŒ¨ (${e}):`, t),
            { success: !1, error: t instanceof Error ? t.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜' }
          )
        }
      }
      async executePortOneBulkPayout(e) {
        try {
          if (!(0, O.isPortOneEnabled)())
            return { success: !1, error: 'PortOne ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ' }
          let t = await y.prisma.groomerSettlement.findMany({
            where: {
              id: { in: e },
              portoneSettlementId: { not: null },
              status: 'READY_FOR_PAYOUT',
            },
          })
          if (0 === t.length) return { success: !1, error: 'ì§€ê¸‰ ê°€ëŠ¥í•œ ì •ì‚°ì´ ì—†ìŒ' }
          let r = t.map((e) => e.portoneSettlementId).filter(Boolean),
            a = (0, O.getPortOneClient)(),
            o = await a.createBulkPayout({
              memo: `ë¯¸ìš©ì‚¬ ì •ì‚° ì¼ê´„ ì§€ê¸‰ - ${t.length}ê±´`,
              partnerSettlementIds: r,
            })
          return (
            await y.prisma.groomerSettlement.updateMany({
              where: { id: { in: e } },
              data: { status: 'PROCESSING' },
            }),
            console.log(`âœ… PortOne ì¼ê´„ ì§€ê¸‰ ì‹¤í–‰: ${o.id} (${t.length}ê±´)`),
            { success: !0, bulkPayoutId: o.id }
          )
        } catch (e) {
          return (
            console.error('PortOne ì¼ê´„ ì§€ê¸‰ ì‹¤íŒ¨:', e),
            { success: !1, error: e instanceof Error ? e.message : 'ì¼ê´„ ì§€ê¸‰ ì‹¤í–‰ ì‹¤íŒ¨' }
          )
        }
      }
    })()
    class T {
      static async scheduleWeeklySettlements(e = 4) {
        return (console.log('âš ï¸ ìë™ ì£¼ê°„ ì •ì‚° ì‘ì—… ì˜ˆì•½ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.'), [])
      }
      static async addManualSettlement(e, t, r, a, o) {
        let n = await y.prisma.settlementJob.create({
          data: {
            jobType: 'MANUAL_SETTLEMENT',
            groomerId: e,
            periodStartDate: t,
            periodEndDate: r,
            scheduledAt: o || new Date(),
            status: 'PENDING',
            createdBy: a,
            notes: 'ê´€ë¦¬ì ìˆ˜ë™ ì •ì‚° ìš”ì²­',
          },
        })
        return (console.log(`ğŸ“ ìˆ˜ë™ ì •ì‚° ì‘ì—… ì¶”ê°€: ${n.id}`), n)
      }
      static async runImmediateSettlement() {
        throw (
          console.log('âš ï¸ ì¦‰ì‹œ ì •ì‚° ì‹¤í–‰ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.'),
          Error('ìë™ ì •ì‚° ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ìˆ˜ë™ ì •ì‚°ì„ ì‚¬ìš©í•˜ì„¸ìš”.')
        )
      }
      static async getJobStatus() {
        return {
          jobs: await y.prisma.settlementJob.findMany({
            orderBy: { createdAt: 'desc' },
            take: 50,
            include: { groomer: { select: { name: !0 } } },
          }),
          summary: (
            await y.prisma.settlementJob.groupBy({ by: ['status'], _count: { status: !0 } })
          ).reduce((e, t) => ((e[t.status] = t._count.status), e), {}),
        }
      }
      static async retryFailedJob(e) {
        let t = await y.prisma.settlementJob.findUnique({ where: { id: e } })
        if (!t || 'FAILED' !== t.status) throw Error('ì¬ì‹œë„í•  ìˆ˜ ì—†ëŠ” ì‘ì—…ì…ë‹ˆë‹¤')
        let r = await y.prisma.settlementJob.create({
          data: {
            jobType: 'RETRY_SETTLEMENT',
            groomerId: t.groomerId,
            periodStartDate: t.periodStartDate,
            periodEndDate: t.periodEndDate,
            scheduledAt: new Date(),
            status: 'PENDING',
            notes: `ì‹¤íŒ¨í•œ ì‘ì—… ì¬ì‹œë„ (ì›ë³¸: ${e})`,
          },
        })
        return (console.log(`ğŸ”„ ì‘ì—… ì¬ì‹œë„: ${r.id}`), r)
      }
      static async cancelJob(e) {
        let t = await y.prisma.settlementJob.update({
          where: { id: e, status: 'PENDING' },
          data: { status: 'CANCELLED' },
        })
        return (console.log(`âŒ ì‘ì—… ì·¨ì†Œ: ${e}`), t)
      }
      static async cleanupOldJobs(e = 30) {
        let t = new Date(Date.now() - 24 * e * 36e5),
          r = await y.prisma.settlementJob.deleteMany({
            where: { createdAt: { lt: t }, status: { in: ['COMPLETED', 'CANCELLED'] } },
          })
        return (console.log(`ğŸ§¹ ì˜¤ë˜ëœ ì •ì‚° ì‘ì—… ${r.count}ê°œ ì •ë¦¬ ì™„ë£Œ`), r)
      }
      static async syncPortOneSettlements(e) {
        if (!(0, O.isPortOneEnabled)())
          return (
            console.log('âš ï¸ PortOne ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ë™ê¸°í™”ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤'),
            { synced: 0, failed: 0 }
          )
        let t = e
            ? await y.prisma.groomerSettlement.findMany({
                where: { id: { in: e }, portoneSettlementId: { not: null } },
              })
            : await y.prisma.groomerSettlement.findMany({
                where: {
                  portoneSettlementId: { not: null },
                  status: { in: ['PROCESSING', 'READY_FOR_PAYOUT'] },
                },
                take: 100,
              }),
          r = 0,
          a = 0
        for (let e of t) {
          try {
            let t = await N.syncPortOneSettlementStatus(e.id)
            t.success ? r++ : (a++, console.error(`ì •ì‚° ë™ê¸°í™” ì‹¤íŒ¨ (${e.id}): ${t.error}`))
          } catch (t) {
            ;(a++, console.error(`ì •ì‚° ë™ê¸°í™” ì¤‘ ì˜¤ë¥˜ (${e.id}):`, t))
          }
          await new Promise((e) => setTimeout(e, 100))
        }
        return (
          console.log(`ğŸ“Š PortOne ì •ì‚° ìƒíƒœ ë™ê¸°í™” ì™„ë£Œ: ${r}ê°œ ì„±ê³µ, ${a}ê°œ ì‹¤íŒ¨`),
          { synced: r, failed: a }
        )
      }
      static async executeBulkPayout(e) {
        if (!(0, O.isPortOneEnabled)()) throw Error('PortOne ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ')
        let t = await N.executePortOneBulkPayout(e)
        return (
          t.success
            ? console.log(`ğŸ’° PortOne ì¼ê´„ ì§€ê¸‰ ì‹¤í–‰ ì™„ë£Œ: ${t.bulkPayoutId}`)
            : console.error(`âŒ PortOne ì¼ê´„ ì§€ê¸‰ ì‹¤íŒ¨: ${t.error}`),
          t
        )
      }
    }
    async function C() {
      try {
        let e = await P.default.api.getSession({ headers: await (0, S.headers)() })
        if (!e || e.user?.role !== 'ADMIN')
          return R.NextResponse.json({ error: 'ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤' }, { status: 403 })
        let t = await T.getJobStatus()
        return R.NextResponse.json({ success: !0, data: { scheduler: { isRunning: !0 }, ...t } })
      } catch (e) {
        return (
          console.error('Error fetching scheduler status:', e),
          R.NextResponse.json(
            { error: 'ìŠ¤ì¼€ì¤„ëŸ¬ ìƒíƒœ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' },
            { status: 500 }
          )
        )
      }
    }
    async function v(e) {
      try {
        let t,
          r = await P.default.api.getSession({ headers: await (0, S.headers)() })
        if (!r || r.user?.role !== 'ADMIN')
          return R.NextResponse.json({ error: 'ê´€ë¦¬ì ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤' }, { status: 403 })
        let { action: a, ...o } = await e.json()
        switch (a) {
          case 'start_scheduler':
            ;(N.start(), (t = { message: 'ìë™ ì •ì‚° ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤' }))
            break
          case 'stop_scheduler':
            ;(N.stop(), (t = { message: 'ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤' }))
            break
          case 'schedule_weekly':
            let n = await T.scheduleWeeklySettlements(o.weeksAhead || 4)
            t = { message: `ìë™ ì£¼ê°„ ì •ì‚° ì‘ì—… ì˜ˆì•½ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤`, jobs: n }
            break
          case 'add_manual':
            if (!o.groomerId || !o.periodStart || !o.periodEnd)
              return R.NextResponse.json(
                { error: 'ìˆ˜ë™ ì •ì‚°ì— í•„ìš”í•œ ë°ì´í„°ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤' },
                { status: 400 }
              )
            let s = await T.addManualSettlement(
              o.groomerId,
              new Date(o.periodStart),
              new Date(o.periodEnd),
              r.user.id,
              o.scheduleTime ? new Date(o.scheduleTime) : void 0
            )
            t = { message: 'ìˆ˜ë™ ì •ì‚° ì‘ì—…ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤', job: s }
            break
          case 'run_immediate':
            try {
              let e = await T.runImmediateSettlement()
              t = { message: 'ì¦‰ì‹œ ì •ì‚° ì‘ì—…ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤', job: e }
            } catch (e) {
              return R.NextResponse.json(
                { error: e instanceof Error ? e.message : 'ì¦‰ì‹œ ì •ì‚° ì‹¤í–‰ ì‹¤íŒ¨' },
                { status: 400 }
              )
            }
            break
          case 'retry_job':
            if (!o.jobId)
              return R.NextResponse.json({ error: 'ì‘ì—… IDê°€ í•„ìš”í•©ë‹ˆë‹¤' }, { status: 400 })
            let i = await T.retryFailedJob(o.jobId)
            t = { message: 'ì‘ì—… ì¬ì‹œë„ê°€ ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤', job: i }
            break
          case 'cancel_job':
            if (!o.jobId)
              return R.NextResponse.json({ error: 'ì‘ì—… IDê°€ í•„ìš”í•©ë‹ˆë‹¤' }, { status: 400 })
            let l = await T.cancelJob(o.jobId)
            t = { message: 'ì‘ì—…ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤', job: l }
            break
          case 'cleanup_jobs':
            let d = await T.cleanupOldJobs(o.daysToKeep || 30)
            t = { message: `${d.count}ê°œì˜ ì˜¤ë˜ëœ ì‘ì—…ì´ ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤`, deleted: d.count }
            break
          default:
            return R.NextResponse.json({ error: `ì•Œ ìˆ˜ ì—†ëŠ” ì•¡ì…˜: ${a}` }, { status: 400 })
        }
        return R.NextResponse.json({ success: !0, ...t })
      } catch (e) {
        return (
          console.error('Error in scheduler action:', e),
          R.NextResponse.json(
            { error: e instanceof Error ? e.message : 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' },
            { status: 500 }
          )
        )
      }
    }
    e.s(['GET', () => C, 'POST', () => v], 681629)
    var k = e.i(681629)
    let x = new t.AppRouteRouteModule({
        definition: {
          kind: r.RouteKind.APP_ROUTE,
          page: '/api/admin/settlement/scheduler/route',
          pathname: '/api/admin/settlement/scheduler',
          filename: 'route',
          bundlePath: '',
        },
        distDir: '.next',
        relativeProjectDir: '',
        resolvedPagePath: '[project]/src/app/api/admin/settlement/scheduler/route.ts',
        nextConfigOutput: 'standalone',
        userland: k,
      }),
      { workAsyncStorage: _, workUnitAsyncStorage: $, serverHooks: j } = x
    function M() {
      return (0, a.patchFetch)({ workAsyncStorage: _, workUnitAsyncStorage: $ })
    }
    async function U(e, t, a) {
      x.isDev && (0, o.addRequestMeta)(e, 'devRequestTimingInternalsEnd', process.hrtime.bigint())
      let R = '/api/admin/settlement/scheduler/route'
      R = R.replace(/\/index$/, '') || '/'
      let S = await x.prepare(e, t, { srcPage: R, multiZoneDraftMode: !1 })
      if (!S)
        return (
          (t.statusCode = 400),
          t.end('Bad Request'),
          null == a.waitUntil || a.waitUntil.call(a, Promise.resolve()),
          null
        )
      let {
          buildId: P,
          params: y,
          nextConfig: b,
          parsedUrl: I,
          isDraftMode: A,
          prerenderManifest: O,
          routerServerContext: D,
          isOnDemandRevalidate: N,
          revalidateOnlyGenerated: T,
          resolvedPathname: C,
          clientReferenceManifest: v,
          serverActionsManifest: k,
        } = S,
        _ = (0, l.normalizeAppPath)(R),
        $ = !!(O.dynamicRoutes[_] || O.routes[C]),
        j = async () => (
          (null == D ? void 0 : D.render404)
            ? await D.render404(e, t, I, !1)
            : t.end('This page could not be found'),
          null
        )
      if ($ && !A) {
        let e = !!O.routes[C],
          t = O.dynamicRoutes[_]
        if (t && !1 === t.fallback && !e) {
          if (b.experimental.adapterPath) return await j()
          throw new E.NoFallbackError()
        }
      }
      let M = null
      !$ || x.isDev || A || (M = '/index' === (M = C) ? '/' : M)
      let U = !0 === x.isDev || !$,
        L = $ && !U
      k &&
        v &&
        (0, s.setReferenceManifestsSingleton)({
          page: R,
          clientReferenceManifest: v,
          serverActionsManifest: k,
          serverModuleMap: (0, i.createServerModuleMap)({ serverActionsManifest: k }),
        })
      let J = e.method || 'GET',
        H = (0, n.getTracer)(),
        F = H.getActiveScopeSpan(),
        q = {
          params: y,
          prerenderManifest: O,
          renderOpts: {
            experimental: { authInterrupts: !!b.experimental.authInterrupts },
            cacheComponents: !!b.cacheComponents,
            supportsDynamicResponse: U,
            incrementalCache: (0, o.getRequestMeta)(e, 'incrementalCache'),
            cacheLifeProfiles: b.cacheLife,
            waitUntil: a.waitUntil,
            onClose: (e) => {
              t.on('close', e)
            },
            onAfterTaskError: void 0,
            onInstrumentationRequestError: (t, r, a) => x.onRequestError(e, t, a, D),
          },
          sharedContext: { buildId: P },
        },
        G = new d.NodeNextRequest(e),
        Y = new d.NodeNextResponse(t),
        B = u.NextRequestAdapter.fromNodeNextRequest(G, (0, u.signalFromNodeResponse)(t))
      try {
        let s = async (e) =>
            x.handle(B, q).finally(() => {
              if (!e) return
              e.setAttributes({ 'http.status_code': t.statusCode, 'next.rsc': !1 })
              let r = H.getRootSpanAttributes()
              if (!r) return
              if (r.get('next.span_type') !== c.BaseServerSpan.handleRequest)
                return void console.warn(
                  `Unexpected root span type '${r.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`
                )
              let a = r.get('next.route')
              if (a) {
                let t = `${J} ${a}`
                ;(e.setAttributes({ 'next.route': a, 'http.route': a, 'next.span_name': t }),
                  e.updateName(t))
              } else e.updateName(`${J} ${R}`)
            }),
          i = !!(0, o.getRequestMeta)(e, 'minimalMode'),
          l = async (o) => {
            var n, l
            let d = async ({ previousCacheEntry: r }) => {
                try {
                  if (!i && N && T && !r)
                    return (
                      (t.statusCode = 404),
                      t.setHeader('x-nextjs-cache', 'REVALIDATED'),
                      t.end('This page could not be found'),
                      null
                    )
                  let n = await s(o)
                  e.fetchMetrics = q.renderOpts.fetchMetrics
                  let l = q.renderOpts.pendingWaitUntil
                  l && a.waitUntil && (a.waitUntil(l), (l = void 0))
                  let d = q.renderOpts.collectedTags
                  if (!$)
                    return (await (0, p.sendResponse)(G, Y, n, q.renderOpts.pendingWaitUntil), null)
                  {
                    let e = await n.blob(),
                      t = (0, h.toNodeOutgoingHttpHeaders)(n.headers)
                    ;(d && (t[w.NEXT_CACHE_TAGS_HEADER] = d),
                      !t['content-type'] && e.type && (t['content-type'] = e.type))
                    let r =
                        void 0 !== q.renderOpts.collectedRevalidate &&
                        !(q.renderOpts.collectedRevalidate >= w.INFINITE_CACHE) &&
                        q.renderOpts.collectedRevalidate,
                      a =
                        void 0 === q.renderOpts.collectedExpire ||
                        q.renderOpts.collectedExpire >= w.INFINITE_CACHE
                          ? void 0
                          : q.renderOpts.collectedExpire
                    return {
                      value: {
                        kind: f.CachedRouteKind.APP_ROUTE,
                        status: n.status,
                        body: Buffer.from(await e.arrayBuffer()),
                        headers: t,
                      },
                      cacheControl: { revalidate: r, expire: a },
                    }
                  }
                } catch (t) {
                  throw (
                    (null == r ? void 0 : r.isStale) &&
                      (await x.onRequestError(
                        e,
                        t,
                        {
                          routerKind: 'App Router',
                          routePath: R,
                          routeType: 'route',
                          revalidateReason: (0, m.getRevalidateReason)({
                            isStaticGeneration: L,
                            isOnDemandRevalidate: N,
                          }),
                        },
                        D
                      )),
                    t
                  )
                }
              },
              u = await x.handleResponse({
                req: e,
                nextConfig: b,
                cacheKey: M,
                routeKind: r.RouteKind.APP_ROUTE,
                isFallback: !1,
                prerenderManifest: O,
                isRoutePPREnabled: !1,
                isOnDemandRevalidate: N,
                revalidateOnlyGenerated: T,
                responseGenerator: d,
                waitUntil: a.waitUntil,
                isMinimalMode: i,
              })
            if (!$) return null
            if (
              (null == u || null == (n = u.value) ? void 0 : n.kind) !== f.CachedRouteKind.APP_ROUTE
            )
              throw Object.defineProperty(
                Error(
                  `Invariant: app-route received invalid cache entry ${null == u || null == (l = u.value) ? void 0 : l.kind}`
                ),
                '__NEXT_ERROR_CODE',
                { value: 'E701', enumerable: !1, configurable: !0 }
              )
            ;(i ||
              t.setHeader(
                'x-nextjs-cache',
                N ? 'REVALIDATED' : u.isMiss ? 'MISS' : u.isStale ? 'STALE' : 'HIT'
              ),
              A &&
                t.setHeader(
                  'Cache-Control',
                  'private, no-cache, no-store, max-age=0, must-revalidate'
                ))
            let c = (0, h.fromNodeOutgoingHttpHeaders)(u.value.headers)
            return (
              (i && $) || c.delete(w.NEXT_CACHE_TAGS_HEADER),
              !u.cacheControl ||
                t.getHeader('Cache-Control') ||
                c.get('Cache-Control') ||
                c.set('Cache-Control', (0, g.getCacheControlHeader)(u.cacheControl)),
              await (0, p.sendResponse)(
                G,
                Y,
                new Response(u.value.body, { headers: c, status: u.value.status || 200 })
              ),
              null
            )
          }
        F
          ? await l(F)
          : await H.withPropagatedContext(e.headers, () =>
              H.trace(
                c.BaseServerSpan.handleRequest,
                {
                  spanName: `${J} ${R}`,
                  kind: n.SpanKind.SERVER,
                  attributes: { 'http.method': J, 'http.target': e.url },
                },
                l
              )
            )
      } catch (t) {
        if (
          (t instanceof E.NoFallbackError ||
            (await x.onRequestError(e, t, {
              routerKind: 'App Router',
              routePath: _,
              routeType: 'route',
              revalidateReason: (0, m.getRevalidateReason)({
                isStaticGeneration: L,
                isOnDemandRevalidate: N,
              }),
            })),
          $)
        )
          throw t
        return (await (0, p.sendResponse)(G, Y, new Response(null, { status: 500 })), null)
      }
    }
    e.s(
      [
        'handler',
        () => U,
        'patchFetch',
        () => M,
        'routeModule',
        () => x,
        'serverHooks',
        () => j,
        'workAsyncStorage',
        () => _,
        'workUnitAsyncStorage',
        () => $,
      ],
      225859
    )
  },
]

//# sourceMappingURL=node_modules_next_dist_esm_build_templates_app-route_357c562e.js.map
